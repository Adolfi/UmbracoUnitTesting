<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Superpower</name>
    </assembly>
    <members>
        <member name="T:Superpower.Combinators">
            <summary>
            Functions that construct more complex parsers by combining simpler ones.
            </summary>
        </member>
        <member name="M:Superpower.Combinators.Apply``2(Superpower.TokenListParser{``0,Superpower.Model.Token{``0}},System.Func{Superpower.Model.Token{``0},Superpower.TextParser{``1}})">
            <summary>
            Apply the text parser <paramref name="valueParser"/> to the span represented by the parsed token.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="valueParser">A function that determines which text parser to apply.</param>
            <returns>A parser that returns the result of parsing the token value.</returns>
        </member>
        <member name="M:Superpower.Combinators.Apply``2(Superpower.TokenListParser{``0,Superpower.Model.Token{``0}},Superpower.TextParser{``1})">
            <summary>
            Apply the text parser <paramref name="valueParser"/> to the span represented by the parsed token.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="valueParser">A text parser to apply.</param>
            <returns>A parser that returns the result of parsing the token value.</returns>
        </member>
        <member name="M:Superpower.Combinators.Apply``1(Superpower.TextParser{Superpower.Model.TextSpan},Superpower.TextParser{``0})">
            <summary>
            Apply the text parser <paramref name="valueParser"/> to the span
            captured by the parser.
            </summary>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="valueParser">A text parser to apply to the span.</param>
            <returns>A parser that returns the result of parsing the span value.</returns>
        </member>
        <member name="M:Superpower.Combinators.AtEnd``1(Superpower.TextParser{``0})">
            <summary>
            Construct a parser that succeeds only if the source is at the end of input.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.AtEnd``2(Superpower.TokenListParser{``0,``1})">
            <summary>
            Construct a parser that succeeds only if the source is at the end of input.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.AtLeastOnce``2(Superpower.TokenListParser{``0,``1})">
            <summary>
            Construct a parser that matches one or more instances of applying <paramref name="parser"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.AtLeastOnce``1(Superpower.TextParser{``0})">
            <summary>
            Construct a parser that matches one or more instances of applying <paramref name="parser"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Repeat``2(Superpower.TokenListParser{``0,``1},System.Int32)">
            <summary>
            Construct a parser that matches a specified number of instances of applying <paramref name="parser"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="count">The number of times to apply <paramref name="parser"/>.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Repeat``1(Superpower.TextParser{``0},System.Int32)">
            <summary>
            Construct a parser that matches a specified number of instances of applying <paramref name="parser"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="count">The number of times to apply <paramref name="parser"/>.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.AtLeastOnceDelimitedBy``3(Superpower.TokenListParser{``0,``1},Superpower.TokenListParser{``0,``2})">
            <summary>
            Construct a parser that matches one or more instances of applying <paramref name="parser"/>, delimited by <paramref name="delimiter"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="delimiter">The parser that matches the delimiters.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.AtLeastOnceDelimitedBy``2(Superpower.TextParser{``0},Superpower.TextParser{``1})">
            <summary>
            Construct a parser that matches one or more instances of applying <paramref name="parser"/>, delimited by <paramref name="delimiter"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="delimiter">The parser that matches the delimiters.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Between``3(Superpower.TokenListParser{``0,``1},Superpower.TokenListParser{``0,``2},Superpower.TokenListParser{``0,``2})">
            <summary>
            Construct a parser that matches <paramref name="left"/>, discards the resulting value,
            then matches <paramref name="parser"/>, keeps the value, then matches <paramref name="right"/>
            and returns the value matched by <paramref name="parser"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="left">First parser to match, value is ignored.</param>
            <param name="right">Last parser to match, value is ignored.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Between``2(Superpower.TextParser{``0},Superpower.TextParser{``1},Superpower.TextParser{``1})">
            <summary>
            Construct a parser that matches <paramref name="left"/>, discards the resulting value,
            then matches <paramref name="parser"/>, keeps the value, then matches <paramref name="right"/>
            and returns the value matched by <paramref name="parser"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="left">First parser to match, value is ignored.</param>
            <param name="right">Last parser to match, value is ignored.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.IgnoreThen``3(Superpower.TokenListParser{``0,``1},Superpower.TokenListParser{``0,``2})">
            <summary>
            Construct a parser that matches <paramref name="first"/>, discards the resulting value, then returns the result of <paramref name="second"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="first">The first parser.</param>
            <param name="second">The second parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.IgnoreThen``2(Superpower.TextParser{``0},Superpower.TextParser{``1})">
            <summary>
            Construct a parser that matches <paramref name="first"/>, discards the resulting value, then returns the result of <paramref name="second"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="first">The first parser.</param>
            <param name="second">The second parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Many``2(Superpower.TokenListParser{``0,``1})">
            <summary>
            Construct a parser that matches <paramref name="parser"/> zero or more times.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
            <remarks>Many will fail if any item partially matches this. To modify this behavior use <see cref="M:Superpower.Combinators.Try``2(Superpower.TokenListParser{``0,``1})"/>.</remarks>
        </member>
        <member name="M:Superpower.Combinators.Many``1(Superpower.TextParser{``0})">
            <summary>
            Construct a parser that matches <paramref name="parser"/> zero or more times.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
            <remarks>Many will fail if any item partially matches this. To modify this behavior use <see cref="M:Superpower.Combinators.Try``1(Superpower.TextParser{``0})"/>.</remarks>
        </member>
        <member name="M:Superpower.Combinators.IgnoreMany``1(Superpower.TextParser{``0})">
            <summary>
            Construct a parser that matches <paramref name="parser"/> zero or more times, discarding the
            result. This is useful for avoiding the array allocation performed by <see cref="M:Superpower.Combinators.Many``1(Superpower.TextParser{``0})"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
            <remarks>IgnoreMany will fail if any item partially matches this. To modify this behavior use <see cref="M:Superpower.Combinators.Try``1(Superpower.TextParser{``0})"/>.</remarks>
        </member>
        <member name="M:Superpower.Combinators.ManyDelimitedBy``3(Superpower.TokenListParser{``0,``1},Superpower.TokenListParser{``0,``2},Superpower.TokenListParser{``0,``2})">
            <summary>
            Construct a parser that matches <paramref name="parser"/> zero or more times, delimited by <paramref name="delimiter"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="delimiter">The parser that matches the delimiters.</param>
            <param name="end">A parser to match a final trailing delimiter, if required. Specifying
            this can improve error reporting for some lists.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.ManyDelimitedBy``2(Superpower.TextParser{``0},Superpower.TextParser{``1})">
            <summary>
            Construct a parser that matches <paramref name="parser"/> zero or more times, delimited by <paramref name="delimiter"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="delimiter">The parser that matches the delimiters.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Message``2(Superpower.TokenListParser{``0,``1},System.String)">
            <summary>
            Construct a parser that fails with error message <paramref name="errorMessage"/> when <paramref name="parser"/> fails.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="errorMessage">The error message.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Message``1(Superpower.TextParser{``0},System.String)">
            <summary>
            Construct a parser that fails with error message <paramref name="errorMessage"/> when <paramref name="parser"/> fails.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="errorMessage">The error message.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Named``2(Superpower.TokenListParser{``0,``1},System.String)">
            <summary>
            Construct a parser that returns <paramref name="name"/> as its "expectation" if <paramref name="parser"/> fails.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="name">The name given to <paramref name="parser"/>.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Named``1(Superpower.TextParser{``0},System.String)">
            <summary>
            Construct a parser that returns <paramref name="name"/> as its "expectation" if <paramref name="parser"/> fails.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="name">The name given to <paramref name="parser"/>.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Optional``2(Superpower.TokenListParser{``0,``1})">
            <summary>
            Construct a parser that matches zero or one instance of <paramref name="parser"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Optional``1(Superpower.TextParser{``0})">
            <summary>
            Construct a parser that matches zero or one instance of <paramref name="parser"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.OptionalOrDefault``2(Superpower.TokenListParser{``0,``1},``1)">
            <summary>
            Construct a parser that matches zero or one instance of <paramref name="parser"/>, returning <paramref name="defaultValue"/> when
            no match is possible.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="defaultValue">The default value</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.OptionalOrDefault``1(Superpower.TextParser{``0},``0)">
            <summary>
            Construct a parser that matches zero or one instance of <paramref name="parser"/>, returning <paramref name="defaultValue"/> when
            no match is possible.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="defaultValue">The default value.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Or``2(Superpower.TokenListParser{``0,``1},Superpower.TokenListParser{``0,``1})">
            <summary>
            Construct a parser that tries first the <paramref name="lhs"/> parser, and if it fails, applies <paramref name="rhs"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="lhs">The first parser to try.</param>
            <param name="rhs">The second parser to try.</param>
            <returns>The resulting parser.</returns>
            <remarks>Or will fail if the first item partially matches this. To modify this behavior use <see cref="M:Superpower.Combinators.Try``2(Superpower.TokenListParser{``0,``1})"/>.</remarks>
        </member>
        <member name="M:Superpower.Combinators.Or``1(Superpower.TextParser{``0},Superpower.TextParser{``0})">
            <summary>
            Construct a parser that tries first the <paramref name="lhs"/> parser, and if it fails, applies <paramref name="rhs"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="lhs">The first parser to try.</param>
            <param name="rhs">The second parser to try.</param>
            <returns>The resulting parser.</returns>
            <remarks>Or will fail if the first item partially matches this. To modify this behavior use <see cref="M:Superpower.Combinators.Try``1(Superpower.TextParser{``0})"/>.</remarks>
        </member>
        <member name="M:Superpower.Combinators.Select``3(Superpower.TokenListParser{``0,``1},System.Func{``1,``2})">
            <summary>
            Construct a parser that takes the result of <paramref name="parser"/> and converts it value using <paramref name="selector"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="selector">A mapping from the first result to the second.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Select``2(Superpower.TextParser{``0},System.Func{``0,``1})">
            <summary>
            Construct a parser that takes the result of <paramref name="parser"/> and converts it value using <paramref name="selector"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="selector">A mapping from the first result to the second.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Cast``3(Superpower.TokenListParser{``0,``1})">
            <summary>
            Construct a parser that takes the result of <paramref name="parser"/> and casts it to <typeparamref name="U"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Cast``2(Superpower.TextParser{``0})">
            <summary>
            Construct a parser that takes the result of <paramref name="parser"/> and casts it to <typeparamref name="U"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.SelectMany``3(Superpower.TextParser{``0},System.Func{``0,Superpower.TextParser{``1}},System.Func{``0,``1,``2})">
            <summary>
            The LINQ query comprehension pattern.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <typeparam name="V"></typeparam>
            <param name="parser">The parser.</param>
            <param name="selector">A mapping from the first result to the second parser.</param>
            <param name="projector">Function mapping the results of the first two parsers onto the final result.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.SelectMany``4(Superpower.TokenListParser{``0,``1},System.Func{``1,Superpower.TokenListParser{``0,``2}},System.Func{``1,``2,``3})">
            <summary>
            The LINQ query comprehension pattern.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <typeparam name="V"></typeparam>
            <param name="parser">The parser.</param>
            <param name="selector">A mapping from the first result to the second parser.</param>
            <param name="projector">Function mapping the results of the first two parsers onto the final result.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Then``3(Superpower.TokenListParser{``0,``1},System.Func{``1,Superpower.TokenListParser{``0,``2}})">
            <summary>
            Construct a parser that applies <paramref name="first"/>, provides the value to <paramref name="second"/> and returns the result.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="first">The first parser.</param>
            <param name="second">The second parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Then``2(Superpower.TextParser{``0},System.Func{``0,Superpower.TextParser{``1}})">
            <summary>
            Construct a parser that applies <paramref name="first"/>, provides the value to <paramref name="second"/> and returns the result.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="first">The first parser.</param>
            <param name="second">The second parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Try``2(Superpower.TokenListParser{``0,``1})">
            <summary>
            Construct a parser that tries one parser, and backtracks if unsuccessful so that no input
            appears to have been consumed by subsequent checks against the result.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Try``1(Superpower.TextParser{``0})">
            <summary>
            Construct a parser that tries one parser, and backtracks if unsuccessful so that no input
            appears to have been consumed by subsequent checks against the result.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Value``3(Superpower.TokenListParser{``0,``1},``2)">
            <summary>
            Construct a parser that applies the first, and returns <paramref name="value"/>.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="value">The value to return.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Value``2(Superpower.TextParser{``0},``1)">
            <summary>
            Construct a parser that applies the first, and returns <paramref name="value"/>.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="U">The type of the resulting value.</typeparam>
            <param name="parser">The parser.</param>
            <param name="value">The value to return.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Where``2(Superpower.TokenListParser{``0,``1},System.Func{``1,System.Boolean})">
            <summary>
            Construct a parser that evaluates the result of a previous parser and fails if <paramref name="predicate"/> returns false
            for the result.
            </summary>
            <typeparam name="TKind">The kind of the tokens being parsed.</typeparam>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="predicate">The predicate to apply.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="M:Superpower.Combinators.Where``1(Superpower.TextParser{``0},System.Func{``0,System.Boolean})">
            <summary>
            Construct a parser that evaluates the result of a previous parser and fails if <paramref name="predicate"/> returns false
            for the result.
            </summary>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <param name="parser">The parser.</param>
            <param name="predicate">The predicate to apply.</param>
            <returns>The resulting parser.</returns>
        </member>
        <member name="T:Superpower.Display.TokenAttribute">
            <summary>
            Applied to enum members representing tokens to control how they are rendered.
            </summary>
        </member>
        <member name="P:Superpower.Display.TokenAttribute.Category">
            <summary>
            The category of the token, e.g. "keyword" or "identifier".
            </summary>
        </member>
        <member name="P:Superpower.Display.TokenAttribute.Example">
            <summary>
            For tokens that correspond to exact text, e.g. punctuation, the canonical
            example of how the token looks.
            </summary>
        </member>
        <member name="P:Superpower.Display.TokenAttribute.Description">
            <summary>
            A description of the token, for example "regular expression".
            </summary>
        </member>
        <member name="T:Superpower.Model.Position">
            <summary>
            A position within a stream of character input.
            </summary>
        </member>
        <member name="P:Superpower.Model.Position.Absolute">
            <summary>
            The zero-based absolute index of the position.
            </summary>
        </member>
        <member name="P:Superpower.Model.Position.Line">
            <summary>
            The one-based line number.
            </summary>
        </member>
        <member name="P:Superpower.Model.Position.Column">
            <summary>
            The one-based column number.
            </summary>
        </member>
        <member name="M:Superpower.Model.Position.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Construct a position.
            </summary>
            <param name="absolute">The absolute position.</param>
            <param name="line">The line number.</param>
            <param name="column">The column number.</param>
        </member>
        <member name="P:Superpower.Model.Position.Zero">
            <summary>
            The position corresponding to the zero index.
            </summary>
        </member>
        <member name="P:Superpower.Model.Position.Empty">
            <summary>
            A position with no value.
            </summary>
        </member>
        <member name="P:Superpower.Model.Position.HasValue">
            <summary>
            True if the position has a value.
            </summary>
        </member>
        <member name="M:Superpower.Model.Position.Advance(System.Char)">
            <summary>
            Advance over <paramref name="overChar"/>, advancing line and column numbers
            as appropriate.
            </summary>
            <param name="overChar">The character being advanced over.</param>
            <returns>The updated position.</returns>
        </member>
        <member name="M:Superpower.Model.Position.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Superpower.Model.Result">
            <summary>
            Helper methods for working with <see cref="T:Superpower.Model.Result`1"/>.
            </summary>
        </member>
        <member name="M:Superpower.Model.Result.Empty``1(Superpower.Model.TextSpan)">
            <summary>
            An empty result indicating no value could be parsed.
            </summary>
            <typeparam name="T">The result type.</typeparam>
            <param name="remainder">The start of un-parsed input.</param>
            <returns>A result.</returns>
        </member>
        <member name="M:Superpower.Model.Result.Empty``1(Superpower.Model.TextSpan,System.String[])">
            <summary>
            An empty result indicating no value could be parsed.
            </summary>
            <typeparam name="T">The result type.</typeparam>
            <param name="remainder">The start of un-parsed input.</param>
            <param name="expectations">Literal descriptions of expectations not met.</param>
            <returns>A result.</returns>
        </member>
        <member name="M:Superpower.Model.Result.Empty``1(Superpower.Model.TextSpan,System.String)">
            <summary>
            An empty result indicating no value could be parsed.
            </summary>
            <typeparam name="T">The result type.</typeparam>
            <param name="remainder">The start of un-parsed input.</param>
            <param name="errorMessage">Error message to present.</param>
            <returns>A result.</returns>
        </member>
        <member name="M:Superpower.Model.Result.Value``1(``0,Superpower.Model.TextSpan,Superpower.Model.TextSpan)">
            <summary>
            A result carrying a successfully-parsed value.
            </summary>
            <typeparam name="T">The result type.</typeparam>
            <param name="value">The value.</param>
            <param name="location">The location corresponding to the beginning of the parsed span.</param>
            <param name="remainder">The start of un-parsed input.</param>
            <returns>A result.</returns>
        </member>
        <member name="M:Superpower.Model.Result.CastEmpty``2(Superpower.Model.Result{``0})">
            <summary>
            Convert an empty result of one type into another.
            </summary>
            <typeparam name="T">The source type.</typeparam>
            <typeparam name="U">The target type.</typeparam>
            <param name="result">The value to convert.</param>
            <returns>A result of type <typeparamref name="U"/> carrying the same information as <paramref name="result"/>.</returns>
        </member>
        <member name="M:Superpower.Model.Result.CombineEmpty``1(Superpower.Model.Result{``0},Superpower.Model.Result{``0})">
            <summary>
            Combine two empty results.
            </summary>
            <typeparam name="T">The source type.</typeparam>
            <param name="first">The first value to combine.</param>
            <param name="second">The second value to combine.</param>
            <returns>A result of type <typeparamref name="T"/> carrying information from both results.</returns>
        </member>
        <member name="T:Superpower.Model.Result`1">
            <summary>
            The result of parsing from a text span.
            </summary>
            <typeparam name="T">The type of the value being parsed.</typeparam>
        </member>
        <member name="P:Superpower.Model.Result`1.Location">
            <summary>
            If the result is a value, the location in the input corresponding to the
            value. If the result is an error, it's the location of the error.
            </summary>
        </member>
        <member name="P:Superpower.Model.Result`1.Remainder">
            <summary>
            The first un-parsed location in the input.
            </summary>
        </member>
        <member name="P:Superpower.Model.Result`1.HasValue">
            <summary>
            True if the result carries a successfully-parsed value; otherwise, false.
            </summary>
        </member>
        <member name="P:Superpower.Model.Result`1.ErrorPosition">
            <summary>
            If the result is an error, the source-level position of the error; otherwise, <see cref="P:Superpower.Model.Position.Empty"/>.
            </summary>
        </member>
        <member name="P:Superpower.Model.Result`1.ErrorMessage">
            <summary>
            A provided error message, or null.
            </summary>
        </member>
        <member name="P:Superpower.Model.Result`1.Expectations">
            <summary>
            A list of expectations that were unmet, or null.
            </summary>
        </member>
        <member name="P:Superpower.Model.Result`1.Value">
            <summary>
            The parsed value.
            </summary>
        </member>
        <member name="M:Superpower.Model.Result`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Superpower.Model.Result`1.FormatErrorMessageFragment">
            <summary>
            If the result is empty, format the fragment of text describing the error.
            </summary>
            <returns>The error fragment.</returns>
        </member>
        <member name="T:Superpower.Model.TextSpan">
            <summary>
            A span of text within a larger string.
            </summary>
        </member>
        <member name="P:Superpower.Model.TextSpan.Source">
            <summary>
            The source string containing the span.
            </summary>
        </member>
        <member name="P:Superpower.Model.TextSpan.Position">
            <summary>
            The position of the start of the span within the string.
            </summary>
        </member>
        <member name="P:Superpower.Model.TextSpan.Length">
            <summary>
            The length of the span.
            </summary>
        </member>
        <member name="M:Superpower.Model.TextSpan.#ctor(System.String)">
            <summary>
            Construct a span encompassing an entire string.
            </summary>
            <param name="source">The source string.</param>
        </member>
        <member name="M:Superpower.Model.TextSpan.#ctor(System.String,Superpower.Model.Position,System.Int32)">
            <summary>
            Construct a string span for a substring of <paramref name="source"/>.
            </summary>
            <param name="source">The source string.</param>
            <param name="position">The start of the span.</param>
            <param name="length">The length of the span.</param>
        </member>
        <member name="P:Superpower.Model.TextSpan.None">
            <summary>
            A span with no value.
            </summary>
        </member>
        <member name="P:Superpower.Model.TextSpan.Empty">
            <summary>
            A span corresponding to the empty string.
            </summary>
        </member>
        <member name="P:Superpower.Model.TextSpan.IsAtEnd">
            <summary>
            True if the span has no content.
            </summary>
        </member>
        <member name="M:Superpower.Model.TextSpan.ConsumeChar">
            <summary>
            Consume a character from the start of the span.
            </summary>
            <returns>A result with the character and remainder.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Superpower.Model.TextSpan.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Superpower.Model.TextSpan.Equals(Superpower.Model.TextSpan)">
            <summary>
            Compare a string span with another using source identity semantics - same source, same position, same length.
            </summary>
            <param name="other">The other span.</param>
            <returns>True if the spans are the same.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.op_Equality(Superpower.Model.TextSpan,Superpower.Model.TextSpan)">
            <summary>
            Compare two spans using source identity semantics.
            </summary>
            <param name="lhs">One span.</param>
            <param name="rhs">Another span.</param>
            <returns>True if the spans are the same.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.op_Inequality(Superpower.Model.TextSpan,Superpower.Model.TextSpan)">
            <summary>
            Compare two spans using source identity semantics.
            </summary>
            <param name="lhs">One span.</param>
            <param name="rhs">Another span.</param>
            <returns>True if the spans are the different.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.Until(Superpower.Model.TextSpan)">
            <summary>
            Return a new span from the start of this span to the beginning of another.
            </summary>
            <param name="next">The next span.</param>
            <returns>A sub-span.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.First(System.Int32)">
            <summary>
            Return a span comprising the first <paramref name="length"/> characters of this span.
            </summary>
            <param name="length">The number of characters to return.</param>
            <returns>The sub-span.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.Skip(System.Int32)">
            <summary>
            Skip a specified number of characters. Note, this is an O(count) operation.
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:Superpower.Model.TextSpan.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Superpower.Model.TextSpan.ToStringValue">
            <summary>
            Compute the string value of this span.
            </summary>
            <returns>A string with the value of this span.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.EqualsValue(System.String)">
            <summary>
            Compare the contents of this span with <paramref name="otherValue"/>.
            </summary>
            <param name="otherValue">The string value to compare.</param>
            <returns>True if the values are the same.</returns>
        </member>
        <member name="M:Superpower.Model.TextSpan.EqualsValueIgnoreCase(System.String)">
            <summary>
            Compare the contents of this span with <paramref name="otherValue"/>, ignoring invariant character case.
            </summary>
            <param name="otherValue">The string value to compare.</param>
            <returns>True if the values are the same ignoring case.</returns>
        </member>
        <member name="T:Superpower.Model.TokenizationState`1">
            <summary>
            Represents the progress of a single tokenization operation.
            </summary>
            <typeparam name="TKind">The kind of token being produced.</typeparam>
        </member>
        <member name="P:Superpower.Model.TokenizationState`1.Previous">
            <summary>
            The last produced token.
            </summary>
        </member>
        <member name="T:Superpower.Model.TokenListParserResult">
            <summary>
            Helper methods for working with <see cref="T:Superpower.Model.TokenListParserResult`2"/>.
            </summary>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult.Empty``2(Superpower.Model.TokenList{``0})">
            <summary>
            Create a token result with no value, indicating a failure to parse any value.
            </summary>
            <typeparam name="TKind">The kind of token.</typeparam>
            <typeparam name="T">The result type.</typeparam>
            <param name="remainder">The start of un-parsed input.</param>
            <returns>An empty result.</returns>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult.Empty``2(Superpower.Model.TokenList{``0},System.String[])">
            <summary>
            Create a token result with no value, indicating a failure to parse any value.
            </summary>
            <typeparam name="TKind">The kind of token.</typeparam>
            <typeparam name="T">The result type.</typeparam>
            <param name="remainder">The start of un-parsed input.</param>
            <param name="expectations">Expectations that could not be fulfilled.</param>
            <returns>An empty result.</returns>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult.Empty``2(Superpower.Model.TokenList{``0},``0[])">
            <summary>
            Create a token result with no value, indicating a failure to parse any value.
            </summary>
            <typeparam name="TKind">The kind of token.</typeparam>
            <typeparam name="T">The result type.</typeparam>
            <param name="remainder">The start of un-parsed input.</param>
            <param name="expectations">Expectations that could not be fulfilled.</param>
            <returns>An empty result.</returns>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult.Empty``2(Superpower.Model.TokenList{``0},System.String)">
            <summary>
            Create a token result with no value, indicating a failure to parse any value.
            </summary>
            <typeparam name="TKind">The kind of token.</typeparam>
            <typeparam name="T">The result type.</typeparam>
            <param name="remainder">The start of un-parsed input.</param>
            <param name="errorMessage">An error message describing why the tokens could not be parsed.</param>
            <returns>An empty result.</returns>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult.Empty``2(Superpower.Model.TokenList{``0},Superpower.Model.Position,System.String)">
            <summary>
            Create a token result with no value, indicating a failure to parse any value.
            </summary>
            <typeparam name="TKind">The kind of token.</typeparam>
            <typeparam name="T">The result type.</typeparam>
            <param name="remainder">The start of un-parsed input.</param>
            <param name="errorPosition">A source position within an individual token where parsing failed. In this case the position will be within
            the first token in <paramref name="remainder"/>.</param>
            <param name="errorMessage">A message describing the problem.</param>
            <returns>An empty result.</returns>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult.Value``2(``1,Superpower.Model.TokenList{``0},Superpower.Model.TokenList{``0})">
            <summary>
            Create a token result with the provided value.
            </summary>
            <typeparam name="TKind">The kind of token.</typeparam>
            <typeparam name="T">The result type.</typeparam>
            <param name="value">The value.</param>
            <param name="location">The location where parsing began.</param>
            <param name="remainder">The first un-parsed location.</param>
            <returns></returns>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult.CastEmpty``3(Superpower.Model.TokenListParserResult{``0,``1})">
            <summary>
            Convert an empty result of one type into another.
            </summary>
            <typeparam name="TKind">The kind of token.</typeparam>
            <typeparam name="T">The source type.</typeparam>
            <typeparam name="U">The destination type.</typeparam>
            <param name="result">The result to convert.</param>
            <returns>The converted result.</returns>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult.CombineEmpty``2(Superpower.Model.TokenListParserResult{``0,``1},Superpower.Model.TokenListParserResult{``0,``1})">
            <summary>
            Combine two empty results.
            </summary>
            <typeparam name="T">The source type.</typeparam>
            <typeparam name="TKind">The kind of token.</typeparam>
            <param name="first">The first value to combine.</param>
            <param name="second">The second value to combine.</param>
            <returns>A result of type <typeparamref name="T"/> carrying information from both results.</returns>
        </member>
        <member name="T:Superpower.Model.TokenListParserResult`2">
            <summary>
            The result of parsing from a token list.
            </summary>
            <typeparam name="T">The type of the value being parsed.</typeparam>
            <typeparam name="TKind">The kind of token being parsed.</typeparam>
        </member>
        <member name="P:Superpower.Model.TokenListParserResult`2.Location">
            <summary>
            If the result has a value, this carries the location of the value in the token
            list. If the result is an error, it's the location of the error.
            </summary>
        </member>
        <member name="P:Superpower.Model.TokenListParserResult`2.Remainder">
            <summary>
            The first un-parsed location in the list.
            </summary>
        </member>
        <member name="P:Superpower.Model.TokenListParserResult`2.HasValue">
            <summary>
            True if the result carries a successfully-parsed value; otherwise, false.
            </summary>
        </member>
        <member name="P:Superpower.Model.TokenListParserResult`2.ErrorPosition">
            <summary>
            If the result is an error, the source-level position of the error; otherwise, <see cref="P:Superpower.Model.Position.Empty"/>.
            </summary>
        </member>
        <member name="P:Superpower.Model.TokenListParserResult`2.SubTokenErrorPosition">
            <summary>
            If the result is an error, the source-level position of the error; otherwise, <see cref="P:Superpower.Model.Position.Empty"/>.
            </summary>
        </member>
        <member name="P:Superpower.Model.TokenListParserResult`2.ErrorMessage">
            <summary>
            A provided error message, or null.
            </summary>
        </member>
        <member name="P:Superpower.Model.TokenListParserResult`2.Expectations">
            <summary>
            A list of expectations that were unmet, or null.
            </summary>
        </member>
        <member name="P:Superpower.Model.TokenListParserResult`2.Value">
            <summary>
            The parsed value.
            </summary>
        </member>
        <member name="M:Superpower.Model.TokenListParserResult`2.ToString">
            <inheritdoc />
        </member>
        <member name="M:Superpower.Model.TokenListParserResult`2.FormatErrorMessageFragment">
            <summary>
            If the result is empty, format the fragment of text describing the error.
            </summary>
            <returns>The error fragment.</returns>
        </member>
        <member name="T:Superpower.Model.TokenList`1">
            <summary>
            A list of <see cref="T:Superpower.Model.Token`1"/>
            </summary>
            <typeparam name="TKind">The kind of tokens held in the list.</typeparam>
        </member>
        <member name="P:Superpower.Model.TokenList`1.Position">
            <summary>
            The position of the token list in the token stream.
            </summary>
        </member>
        <member name="M:Superpower.Model.TokenList`1.#ctor(Superpower.Model.Token{`0}[])">
            <summary>
            Construct a token list containing <paramref name="tokens"/>.
            </summary>
            <param name="tokens">The tokens in the list.</param>
        </member>
        <member name="P:Superpower.Model.TokenList`1.Empty">
            <summary>
            A token list with no value.
            </summary>
        </member>
        <member name="P:Superpower.Model.TokenList`1.IsAtEnd">
            <summary>
            True if the token list contains no tokens.
            </summary>
        </member>
        <member name="M:Superpower.Model.TokenList`1.ConsumeToken">
            <summary>
            Consume a token from the start of the list, returning a result with the token and remainder.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Superpower.Model.TokenList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Superpower.Model.TokenList`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Superpower.Model.TokenList`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Superpower.Model.TokenList`1.Equals(Superpower.Model.TokenList{`0})">
            <summary>
            Compare two token lists using identity semantics - same list, same position.
            </summary>
            <param name="other">The other token list.</param>
            <returns>True if the token lists are the same.</returns>
        </member>
        <member name="M:Superpower.Model.TokenList`1.op_Equality(Superpower.Model.TokenList{`0},Superpower.Model.TokenList{`0})">
            <summary>
            Compare two token lists using identity semantics.
            </summary>
            <param name="lhs">The first token list.</param>
            <param name="rhs">The second token list.</param>
            <returns>True if the token lists are the same.</returns>
        </member>
        <member name="M:Superpower.Model.TokenList`1.op_Inequality(Superpower.Model.TokenList{`0},Superpower.Model.TokenList{`0})">
            <summary>
            Compare two token lists using identity semantics.
            </summary>
            <param name="lhs">The first token list.</param>
            <param name="rhs">The second token list.</param>
            <returns>True if the token lists are the different.</returns>
        </member>
        <member name="M:Superpower.Model.TokenList`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Superpower.Model.Token`1">
            <summary>
            A token.
            </summary>
            <typeparam name="TKind">The type of the token's kind.</typeparam>
        </member>
        <member name="P:Superpower.Model.Token`1.Kind">
            <summary>
            The kind of the token.
            </summary>
        </member>
        <member name="P:Superpower.Model.Token`1.Span">
            <summary>
            The string span containing the value of the token.
            </summary>
        </member>
        <member name="M:Superpower.Model.Token`1.ToStringValue">
            <summary>
            Get the string value of the token.
            </summary>
            <returns>The token as a string.</returns>
        </member>
        <member name="P:Superpower.Model.Token`1.Position">
            <summary>
            The position of the token within the source string.
            </summary>
        </member>
        <member name="P:Superpower.Model.Token`1.HasValue">
            <summary>
            True if the token has a value.
            </summary>
        </member>
        <member name="M:Superpower.Model.Token`1.#ctor(`0,Superpower.Model.TextSpan)">
            <summary>
            Construct a token.
            </summary>
            <param name="kind">The kind of the token.</param>
            <param name="span">The span holding the token's value.</param>
        </member>
        <member name="P:Superpower.Model.Token`1.Empty">
            <summary>
            A token with no value.
            </summary>
        </member>
        <member name="M:Superpower.Model.Token`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Superpower.Model.Unit">
            <summary>
            A structure with no information.
            </summary>
        </member>
        <member name="P:Superpower.Model.Unit.Value">
            <summary>
            The singleton value of the struct, with no value.
            </summary>
        </member>
        <member name="T:Superpower.Parse">
            <summary>
            General parsing helper methods.
            </summary>
        </member>
        <member name="M:Superpower.Parse.Chain``2(Superpower.TextParser{``1},Superpower.TextParser{``0},System.Func{``1,``0,``0,``0})">
            <summary>
            Parse a sequence of operands connected by left-associative operators.
            </summary>
            <typeparam name="T">The type being parsed.</typeparam>
            <typeparam name="TOperator">The type of the operator.</typeparam>
            <param name="operator">A parser matching operators.</param>
            <param name="operand">A parser matching operands.</param>
            <param name="apply">A function combining an operator and two operands into the result.</param>
            <returns>The result of calling <paramref name="apply"/> successively on pairs of operands.</returns>
        </member>
        <member name="M:Superpower.Parse.ChainRight``2(Superpower.TextParser{``1},Superpower.TextParser{``0},System.Func{``1,``0,``0,``0})">
            <summary>
            Parse a sequence of operands connected by right-associative operators.
            </summary>
            <typeparam name="T">The type being parsed.</typeparam>
            <typeparam name="TOperator">The type of the operator.</typeparam>
            <param name="operator">A parser matching operators.</param>
            <param name="operand">A parser matching operands.</param>
            <param name="apply">A function combining an operator and two operands into the result.</param>
            <returns>The result of calling <paramref name="apply"/> successively on pairs of operands.</returns>
        </member>
        <member name="M:Superpower.Parse.Chain``3(Superpower.TokenListParser{``0,``2},Superpower.TokenListParser{``0,``1},System.Func{``2,``1,``1,``1})">
            <summary>
            Parse a sequence of operands connected by left-associative operators.
            </summary>
            <typeparam name="T">The type being parsed.</typeparam>
            <typeparam name="TOperator">The type of the operator.</typeparam>
            <typeparam name="TKind">The kind of token being parsed.</typeparam>
            <param name="operator">A parser matching operators.</param>
            <param name="operand">A parser matching operands.</param>
            <param name="apply">A function combining an operator and two operands into the result.</param>
            <returns>The result of calling <paramref name="apply"/> successively on pairs of operands.</returns>
        </member>
        <member name="M:Superpower.Parse.ChainRight``3(Superpower.TokenListParser{``0,``2},Superpower.TokenListParser{``0,``1},System.Func{``2,``1,``1,``1})">
            <summary>
            Parse a sequence of operands connected by right-associative operators.
            </summary>
            <typeparam name="T">The type being parsed.</typeparam>
            <typeparam name="TOperator">The type of the operator.</typeparam>
            <typeparam name="TKind">The kind of token being parsed.</typeparam>
            <param name="operator">A parser matching operators.</param>
            <param name="operand">A parser matching operands.</param>
            <param name="apply">A function combining an operator and two operands into the result.</param>
            <returns>The result of calling <paramref name="apply"/> successively on pairs of operands.</returns>
        </member>
        <member name="M:Superpower.Parse.Not``1(Superpower.TextParser{``0})">
            <summary>
            Constructs a parser that will fail if the given parser succeeds,
            and will succeed if the given parser fails. In any case, it won't
            consume any input. It's like a negative look-ahead in a regular expression.
            </summary>
            <typeparam name="T">The result type of the given parser</typeparam>
            <param name="parser">The parser to wrap</param>
            <returns>A parser that is the negation of the given parser.</returns>
        </member>
        <member name="M:Superpower.Parse.Not``2(Superpower.TokenListParser{``0,``1})">
            <summary>
            Constructs a parser that will fail if the given parser succeeds,
            and will succeed if the given parser fails. In any case, it won't
            consume any input. It's like a negative look-ahead in a regular expression.
            </summary>
            <typeparam name="T">The result type of the given parser.</typeparam>
            <typeparam name="TKind">The kind of token being parsed.</typeparam>
            <param name="parser">The parser to wrap</param>
            <returns>A parser that is the negation of the given parser.</returns>
        </member>
        <member name="M:Superpower.Parse.Ref``1(System.Func{Superpower.TextParser{``0}})">
            <summary>
            Lazily construct a parser, so that circular dependencies are possible.
            </summary>
            <param name="reference">A function creating the parser, when required.</param>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <returns>A parser that lazily evaluates <paramref name="reference"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reference"/> is null.</exception>
        </member>
        <member name="M:Superpower.Parse.Ref``2(System.Func{Superpower.TokenListParser{``0,``1}})">
            <summary>
            Lazily construct a parser, so that circular dependencies are possible.
            </summary>
            <param name="reference">A function creating the parser, when required.</param>
            <typeparam name="T">The type of value being parsed.</typeparam>
            <typeparam name="TKind">The kind of token being parsed.</typeparam>
            <returns>A parser that lazily evaluates <paramref name="reference"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="reference"/> is null.</exception>
        </member>
        <member name="M:Superpower.Parse.Return``1(``0)">
            <summary>
            Construct a parser with a fixed value.
            </summary>
            <param name="value">The value returned by the parser.</param>
            <typeparam name="T">The type of <paramref name="value"/>.</typeparam>
            <returns>The parser.</returns>
        </member>
        <member name="M:Superpower.Parse.Return``2(``1)">
            <summary>
            Construct a parser with a fixed value.
            </summary>
            <param name="value">The value returned by the parser.</param>
            <typeparam name="T">The type of <paramref name="value"/>.</typeparam>
            <typeparam name="TKind">The kind of token being parsed.</typeparam>
            <returns>The parser.</returns>
        </member>
        <member name="T:Superpower.ParseException">
            <summary>
            Represents an error that occurs during parsing.
            </summary>
        </member>
        <member name="M:Superpower.ParseException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Superpower.ParseException" /> class.
            </summary>
        </member>
        <member name="M:Superpower.ParseException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Superpower.ParseException" /> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Superpower.ParseException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Superpower.ParseException" /> class with a specified error message 
            and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, 
            or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="T:Superpower.ParserExtensions">
            <summary>
            Helper methods for working with parsers.
            </summary>
        </member>
        <member name="M:Superpower.ParserExtensions.TryParse``1(Superpower.TextParser{``0},System.String)">
            <summary>
            Tries to parse the input without throwing an exception upon failure.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="parser">The parser.</param>
            <param name="input">The input.</param>
            <returns>The result of the parser</returns>
            <exception cref="T:System.ArgumentNullException">The parser or input is null.</exception>
        </member>
        <member name="M:Superpower.ParserExtensions.TryParse``2(Superpower.TokenListParser{``0,``1},Superpower.Model.TokenList{``0})">
            <summary>
            Tries to parse the input without throwing an exception upon failure.
            </summary>
            <typeparam name="TKind">The type of tokens consumed by the parser.</typeparam>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="parser">The parser.</param>
            <param name="input">The input.</param>
            <returns>The result of the parser</returns>
            <exception cref="T:System.ArgumentNullException">The parser or input is null.</exception>
        </member>
        <member name="M:Superpower.ParserExtensions.Parse``1(Superpower.TextParser{``0},System.String)">
            <summary>
            Parses the specified input string.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="parser">The parser.</param>
            <param name="input">The input.</param>
            <returns>The result of the parser.</returns>
            <exception cref="T:System.ArgumentNullException">The parser or input is null.</exception>
            <exception cref="T:Superpower.ParseException">It contains the details of the parsing error.</exception>
        </member>
        <member name="M:Superpower.ParserExtensions.Parse``2(Superpower.TokenListParser{``0,``1},Superpower.Model.TokenList{``0})">
            <summary>
            Parses the specified input.
            </summary>
            <typeparam name="TKind">The type of tokens consumed by the parser.</typeparam>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="parser">The parser.</param>
            <param name="input">The input.</param>
            <returns>The result of the parser.</returns>
            <exception cref="T:System.ArgumentNullException">The parser or input is null.</exception>
            <exception cref="T:Superpower.ParseException">It contains the details of the parsing error.</exception>
        </member>
        <member name="M:Superpower.ParserExtensions.IsMatch``1(Superpower.TextParser{``0},Superpower.Model.TextSpan)">
            <summary>
            Tests whether the parser matches the entire provided <see cref="T:Superpower.Model.TextSpan"/>.
            </summary>
            <typeparam name="T">The type of the parser's result.</typeparam>
            <param name="parser">The parser.</param>
            <param name="input">The input.</param>
            <returns>True if the parser is a complete match for the input; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">The parser is null.</exception>
            <exception cref="T:System.ArgumentException">The input is <see cref="P:Superpower.Model.TextSpan.Empty"/>.</exception>
        </member>
        <member name="T:Superpower.Parsers.Character">
            <summary>
            Parsers for matching individual characters.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Character.Matching(System.Func{System.Char,System.Boolean},System.String)">
            <summary>
            Parse a single character matching <paramref name="predicate"/>.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Character.Except(System.Func{System.Char,System.Boolean},System.String)">
            <summary>
            Parse a single character except those matching <paramref name="predicate"/>.
            </summary>
            <param name="predicate">Characters not to match.</param>
            <param name="description">Description of characters that don't match.</param>
            <returns>A parser for characters except those matching <paramref name="predicate"/>.</returns>
        </member>
        <member name="M:Superpower.Parsers.Character.EqualTo(System.Char)">
            <summary>
            Parse a single specified character.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Character.EqualToIgnoreCase(System.Char)">
            <summary>
            Parse a single specified character, ignoring case differences.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Character.In(System.Char[])">
            <summary>
            Parse any single character in <paramref name="chars"/>.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Character.Except(System.Char)">
            <summary>
            Parse a single character except <paramref name="ch"/>.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Character.ExceptIn(System.Char[])">
            <summary>
            Parse any single character except those in <paramref name="chars"/>.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.AnyChar">
            <summary>
            Parse any character.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.WhiteSpace">
            <summary>
            Parse a whitespace character.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.Digit">
            <summary>
            Parse a digit.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.Letter">
            <summary>
            Parse a letter.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.LetterOrDigit">
            <summary>
            Parse a letter or digit.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.Lower">
            <summary>
            Parse a lowercase letter.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.Upper">
            <summary>
            Parse an uppercase letter.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.Numeric">
            <summary>
            Parse a numeric character.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Character.HexDigit">
            <summary>
            Parse a hexadecimal digit (0-9, a-f, A-F).
            </summary>
        </member>
        <member name="T:Superpower.Parsers.Comment">
            <summary>
            Parsers for matching comments in various styles.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Comment.ToEndOfLine(Superpower.TextParser{Superpower.Model.TextSpan})">
            <summary>
            Parses a comment that begins with a specified pattern and continues to the end of the line.
            </summary>
            <remarks>
            The comment span does not include the end-of-line characters that terminate it.
            </remarks>
            <param name="beginComment">Recognizes the beginning of the comment.</param>
            <returns>The span covered by the comment.</returns>
        </member>
        <member name="P:Superpower.Parsers.Comment.CPlusPlusStyle">
            <summary>
            Parses a C++ style comment, beginning with a double forward slash `//`
            and continuing to the end of the line.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Comment.SqlStyle">
            <summary>
            Parses a SQL style comment, beginning with a double dash `--`
            and continuing to the end of the line.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Comment.ShellStyle">
            <summary>
            Parses a shell style comment, beginning with a pound/hash `#` sign
            and continuing to the end of the line.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Comment.CStyle">
            <summary>
            Parses a C-style multiline comment beginning with `/*` and ending with `*/`.
            </summary>
        </member>
        <member name="T:Superpower.Parsers.Identifier">
            <summary>
            Parsers for matching identifiers in various styles.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Identifier.CStyle">
            <summary>
            Parse a <code>C_Style</code> identifier.
            </summary>
        </member>
        <member name="T:Superpower.Parsers.Instant">
            <summary>
            Parsers for matching date and time formats.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Instant.Iso8601DateTime">
            <summary>
            Matches ISO-8601 datetimes.
            </summary>
        </member>
        <member name="T:Superpower.Parsers.Numerics">
            <summary>
            Parsers for numeric patterns.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Numerics.Natural">
            <summary>
            A string of digits.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Numerics.NaturalUInt32">
            <summary>
            A string of digits, converted into a <see cref="T:System.UInt32"/>.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Numerics.NaturalUInt64">
            <summary>
            A string of digits, converted into a <see cref="T:System.UInt64"/>.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Numerics.Integer">
            <summary>
            A string of digits with an optional +/- sign.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Numerics.IntegerInt32">
            <summary>
            A string of digits with an optional +/- sign, converted into an <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Numerics.IntegerInt64">
            <summary>
            A string of digits with an optional +/- sign, converted into an <see cref="T:System.Int64"/>.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Numerics.Decimal">
            <summary>
            Matches decimal numbers, for example <code>-1.23</code>.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Numerics.HexDigits">
            <summary>
            Matches hexadecimal numbers.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Numerics.HexDigitsUInt32">
            <summary>
            A string of hexadecimal digits, converted into a <see cref="T:System.UInt32"/>.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Numerics.HexDigitsUInt64">
            <summary>
            A string of hexadecimal digits, converted into a <see cref="T:System.UInt64"/>.
            </summary>
        </member>
        <member name="T:Superpower.Parsers.QuotedString">
            <summary>
            Parsers for matching strings in various styles.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.QuotedString.SqlStyle">
            <summary>
            A <code>'SQL-style'</code> string. Single quote delimiters, with embedded single quotes
            escaped by '' doubling.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.QuotedString.CStyle">
            <summary>
            A <code>"C-style"</code> string. Double quote delimiters, with ability to escape
            characters by using <code>\"</code>.
            </summary>
        </member>
        <member name="T:Superpower.Parsers.Span">
            <summary>
            Parsers for spans of characters.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Span.Length(System.Int32)">
            <summary>
            Parse a span of length <paramref name="length"/>/>.
            </summary>
            <param name="length">The number of characters to parse.</param>
            <returns>The parsed span.</returns>
        </member>
        <member name="M:Superpower.Parsers.Span.EqualTo(System.String)">
            <summary>
            Match a span equal to <paramref name="text"/>.
            </summary>
            <param name="text">The text to match.</param>
            <returns>The matched text.</returns>
        </member>
        <member name="M:Superpower.Parsers.Span.EqualToIgnoreCase(System.String)">
            <summary>
            Match a span equal to <paramref name="text"/>, ignoring invariant case.
            </summary>
            <param name="text">The text to match.</param>
            <returns>The matched text.</returns>
        </member>
        <member name="M:Superpower.Parsers.Span.EqualTo(System.Char)">
            <summary>
            Match a span equal to a single character <paramref name="ch"/>.
            </summary>
            <param name="ch">The character to match.</param>
            <returns>The matched text.</returns>
        </member>
        <member name="M:Superpower.Parsers.Span.EqualToIgnoreCase(System.Char)">
            <summary>
            Match a span equal to a single character <paramref name="ch"/>, ignoring invariant character case.
            </summary>
            <param name="ch">The character to match.</param>
            <returns>The matched text.</returns>
        </member>
        <member name="M:Superpower.Parsers.Span.WithoutAny(System.Func{System.Char,System.Boolean})">
            <summary>
            Parse until finding a character for which <paramref name="predicate"/> returns true.
            </summary>
            <param name="predicate">A predicate.</param>
            <returns>The matched text.</returns>
        </member>
        <member name="M:Superpower.Parsers.Span.WithAll(System.Func{System.Char,System.Boolean})">
            <summary>
            Parse until finding a character for which <paramref name="predicate"/> returns false.
            </summary>
            <param name="predicate">A predicate.</param>
            <returns>The matched text.</returns>
        </member>
        <member name="P:Superpower.Parsers.Span.WhiteSpace">
            <summary>
            Parse until a non-whitespace character is encountered, returning the matched span of whitespace.
            </summary>
        </member>
        <member name="P:Superpower.Parsers.Span.NonWhiteSpace">
            <summary>
            Parse until a whitespace character is encountered, returning the matched span of non-whitespace characters.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Span.Regex(System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Parse as much of the input as matches <paramref name="regex" />.
            </summary>
            <param name="regex">A regular expression. The expression should not be anchored with `^` (beginning of input), `$` (end of input) etc.</param>
            <param name="options">Options to apply to the expression. Specifying `RegexOptions.Compiled` may speed up some cases.</param>
            <returns>A parser that will match text matching the expression.</returns>
            <exception cref="T:System.ArgumentNullException">The expression is null.</exception>
        </member>
        <member name="M:Superpower.Parsers.Span.MatchedBy``1(Superpower.TextParser{``0})">
            <summary>
            A handy adapter that takes any text parser, regardless of its result
            type, and returns the span consumed by that parser.
            </summary>
            <param name="parser">A parser to apply.</param>
            <typeparam name="T">The parser's (ignored) result type.</typeparam>
            <returns>A parser that will match the span covered by <paramref name="parser"/>.</returns>
        </member>
        <member name="T:Superpower.Parsers.Token">
            <summary>
            Parsers for matching individual tokens.
            </summary>
        </member>
        <member name="M:Superpower.Parsers.Token.EqualTo``1(``0)">
            <summary>
            Parse a token of the kind <typeparamref name="TKind"/>.
            </summary>
            <typeparam name="TKind">The type of the token being matched.</typeparam>
            <param name="kind">The kind of token to match.</param>
            <returns>The matched token.</returns>
        </member>
        <member name="M:Superpower.Parsers.Token.Sequence``1(``0[])">
            <summary>
            Parse a sequence of tokens of the kind <typeparamref name="TKind"/>.
            </summary>
            <typeparam name="TKind">The type of the tokens being matched.</typeparam>
            <param name="kinds">The kinds of token to match, once each in order.</param>
            <returns>The matched tokens.</returns>
        </member>
        <member name="M:Superpower.Parsers.Token.EqualToValue``1(``0,System.String)">
            <summary>
            Parse a token where the span of text matches a particular value.
            </summary>
            <param name="kind">The kind of token to match.</param>
            <param name="value">The string value to compare against the token's underlying span.</param>
            <typeparam name="TKind">The type of the token being matched.</typeparam>
            <returns>A parser that will match tokens with the specified kind and value.</returns>
        </member>
        <member name="M:Superpower.Parsers.Token.EqualToValueIgnoreCase``1(``0,System.String)">
            <summary>
            Parse a token where the span of text matches a particular value, ignoring invariant character case.
            </summary>
            <param name="kind">The kind of token to match.</param>
            <param name="value">The string value to compare against the token's underlying span.</param>
            <typeparam name="TKind">The type of the token being matched.</typeparam>
            <returns>A parser that will match tokens with the specified kind and value.</returns>
        </member>
        <member name="T:Superpower.TextParser`1">
            <summary>
            A parser that consumes text from a string span.
            </summary>
            <typeparam name="T">The type of values produced by the parser.</typeparam>
            <param name="input">The span of text to parse.</param>
            <returns>A result with a parsed value, or an empty result indicating error.</returns>
        </member>
        <member name="T:Superpower.Tokenizers.TokenizerBuilder`1">
            <summary>
            Builds a simple tokenizer given information about tokens and whitespace.
            </summary>
            <remarks>Provides a quick way to get started with a simple
            tokenizer that matches the input against a list of possible token
            recognizers.</remarks>
            <typeparam name="TKind">The kind of token the tokenizer will
            produce.</typeparam>
        </member>
        <member name="M:Superpower.Tokenizers.TokenizerBuilder`1.Match``1(Superpower.TextParser{``0},`0,System.Boolean)">
            <summary>
            Add a recognizer for a kind of token. Recognizers are tried in the order
            in which they are added.
            </summary>
            <param name="recognizer">A parser that will recognize the token.</param>
            <param name="kind">The kind of token the recognizer will recognize.</param>
            <param name="requireDelimiters">If true, the token must be preceded and followed
            by either the beginning or end-of-input, an ignored (whitespace) character,
            or a token kind that does not require delimiters. Generally set to `true` for
            keywords/identifiers, otherwise, use the default value of `false`.</param>
            <typeparam name="U">The value produced by the recognizer, if any. This
            will be ignored.</typeparam>
            <returns>The builder, to allow method chaining.</returns>
        </member>
        <member name="M:Superpower.Tokenizers.TokenizerBuilder`1.Ignore``1(Superpower.TextParser{``0})">
            <summary>
            Add a recognizer for a whitespace/ignored text.
            </summary>
            <param name="ignored">A recognizer for the ignored text.</param>
            <typeparam name="U">The value produced by the recognizer, if any. This
            will be ignored.</typeparam>
            <returns>The builder, to allow method chaining.</returns>
        </member>
        <member name="M:Superpower.Tokenizers.TokenizerBuilder`1.Build">
            <summary>
            Build the tokenizer.
            </summary>
            <returns>The tokenizer.</returns>
        </member>
        <member name="M:Superpower.Tokenizers.TokenizerBuilder`1.SimpleLinearTokenizer.Tokenize(Superpower.Model.TextSpan)">
            <inheritdoc/>
            <remarks>
            The complexity in this method is due to the desire to distinguish between (e.g. in C#)
            the keyworkd `null` vs the identifier `nullability`. The tokenizer, when it encounters
            a non-delimiter match (like `null`), looks ahead to see whether it's immediately followed
            by a delimiter or end-of-input. If not, the match is discarded and subsequent recognizers
            are tested.
            </remarks>
        </member>
        <member name="T:Superpower.Tokenizer`1">
            <summary>
            Base class for tokenizers, types whose instances convert strings into lists of tokens.
            </summary>
            <typeparam name="TKind">The kind of tokens produced.</typeparam>
        </member>
        <member name="M:Superpower.Tokenizer`1.Tokenize(System.String)">
            <summary>
            Tokenize <paramref name="source"/>.
            </summary>
            <param name="source">The source to tokenize.</param>
            <returns>The list of tokens or an error.</returns>
            <exception cref="T:Superpower.ParseException">Tokenization failed.</exception>
        </member>
        <member name="M:Superpower.Tokenizer`1.TryTokenize(System.String)">
            <summary>
            Tokenize <paramref name="source"/>.
            </summary>
            <param name="source">The source to tokenize.</param>
            <returns>A result with the list of tokens or an error.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
            <exception cref="T:Superpower.ParseException">The tokenizer could not correctly perform tokenization.</exception>
        </member>
        <member name="M:Superpower.Tokenizer`1.Tokenize(Superpower.Model.TextSpan)">
            <summary>
            Subclasses should override to perform tokenization.
            </summary>
            <param name="span">The input span to tokenize.</param>
            <returns>A list of parsed tokens.</returns>
        </member>
        <member name="M:Superpower.Tokenizer`1.Tokenize(Superpower.Model.TextSpan,Superpower.Model.TokenizationState{`0})">
            <summary>
            Subclasses should override to perform tokenization when the
            last-produced-token needs to be tracked.
            </summary>
            <param name="span">The input span to tokenize.</param>
            <param name="state">The tokenization state maintained during the operation.</param>
            <returns>A list of parsed tokens.</returns>
        </member>
        <member name="M:Superpower.Tokenizer`1.SkipWhiteSpace(Superpower.Model.TextSpan)">
            <summary>
            Advance until the first non-whitespace character is encountered.
            </summary>
            <param name="span">The span to advance from.</param>
            <returns>A result with the first non-whitespace character.</returns>
        </member>
        <member name="T:Superpower.TokenListParser`2">
            <summary>
            A parser that consumes elements from a list of tokens.
            </summary>
            <typeparam name="T">The type of values produced by the parser.</typeparam>
            <typeparam name="TKind">The type of tokens being parsed.</typeparam>
            <param name="input">The list of tokens to parse.</param>
            <returns>A result with a parsed value, or an empty result indicating error.</returns>
        </member>
    </members>
</doc>
